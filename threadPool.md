
没有pthread_join主线程会很快结束从而使整个进程结束，从而使创建的线程没有机会开始执行就结束了。
加入pthread_join后，主线程会一直等待直到等待的线程结束自己才结束，使创建的线程有机会执行


线程池/任务池
http://www.oschina.net/code/snippet_1987090_44422?p=2#comments
https://github.com/wgfxcu/libstpool
1.系统空闲时候线程能自动退出.任务到来时候自动启动线程服务
2.线程池自动根据任务执行时间和数量智能启动合适的线程数目来服务.达到最好的调度性能
3.支持优先级任务,同时内置内存对象池,减少运行时间长带来的内存碎片
4.能随时调整和控制线程池中服务线程上下限
5.跨平台,同时支持 c, c++
6.线程池能同时支持任意类型的任务, 一个线程池中如果加入延时的，和非延时的，
         以及延时到一定程度的等各种不同类型的任务,stpool都能完美的工作.能选择最合适
         的线程数目来提供服务  (可自行编写demo连接debug库进行实时监控验证)

         
应用场景:
        适合间歇性或者持续性的并发程度高,任务执行时间较短的应用系统. 
     比如下面一些常用的应用场景.
           1.高并发服务器,利用线程池来提高响应度
           2.在没有asio的系统上利用线程池实现asio是对用户大量回调的反馈
           3.对应用数据的预处理,比如web服务用户接入时需要用户验证等都可以作为
              预处理等放入线程池处理,完成后再放入统一的事件调度器中(如libevent)
             ,提高web高并发访问.
           4.并行计算, 如在多核CPU上进行数据并行帧数据编解码.
           5.网络爬虫或者文件并行搜索,下载等
           6.临时多任务处理加速.(比如: 程序启动时按任务进行服务加速,多视频通道打开加速)