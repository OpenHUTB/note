

# 计算机体系结构

1.
个人计算机是人类迄今创造的最强大工具，我认为这种说法并无偏颇。它们是通信工具，是创造工具，是可以由用户定制的工具。
一一比尔·盖茨，
2004 年2 月24 日

2. 存储器层次结构设计

理想情况下，我们希望拥有无限大的内存容量，这样就可以立刻访问任何一个特定的·…..机器字..…·但我们……不得不认识到有可能需要构建分层结构的存储器，每一层次容量都要大于前一层次，但其访问速度也要更慢一些。
A. W. Burks 、H. H. Goldstine 及
J. von N田Jrn目m，
Preliminary Díscussion of the
Logical Design of an Electronic
Computing Ins阳ment (1946)


3. 指令级并行及其开发



4. 
如果要耕种一块地，那你会选择两头强壮的公牛呢，还是1024只小鸡?
一-Seymour Cray，超级计算机之父
(争论的是选择两个功能强大的性处理器，还是选择许多简单的的处理器。)

5
计算机组织结构在 20 世纪 60 年代中期开始偏离传统方式，在提升计算机运行速度的努力中，回报递减定律开始发挥作用…… 电子电路的运行速度最终受光速的限制……许多电路已经工作在纳秒级别。
一一-W.JackBo咏night 等人，
The IIliac IV System (1972)

细节决定成败。
一一一经典谚语


6. 以仓库级计算机开发请求级、数据级并行

数据中心就是计算机。
一一-Luiz André Barroso，
Google (2007)

谁都可以搭建一块快速CPU。难点在于如何搭建一个快速系统。
一一 Seymour Gray ，
公认的超级计算机之父

如果一个问题没有解决的办法，那它可能就不是一个问题，而是一个事实一一不是找到其解决办法，而是随着时间的推移找到应对方法。
一-Shimon Peres


# 人月神话

巴比伦塔项目的失败是因为缺乏交流，以及交流的结果——组织。

团队组织的目标是为了减少必要的交流和协作量。

项目是怎样延迟了整整一年的时间？⋯一次一天。


#《神经网络与深度学习》
一个人在不接触对方的情况下，通过一种特殊的方式，和对方进行一系列的问答。如果在相当长时间内，他无法根据这些问题判断对方是人还是计算机，那么就可以认为这个计算机是智能的。
— 阿兰·图灵[1950]，《Computing Machinery and Intelligence 》

机器学习是对能通过经验自动改进的计算机算法的研究。
— Mitchell [1997]

正确的判断来自于经验，而经验来自于错误的判断。
— Frederick P. Brooks

神经网络是一种大规模的并行分布式处理器，天然具有存储并使用经验知识的能力。它从两个方面上模拟大脑：（1）网络获取的知识是通过学习来获取的；（2）内部神经元的连接强度，即突触权重，用于储存获取的知识。
— Haykin [1994]

一切都应该尽可能地简单，但不能过于简单。
— 艾伯特· 爱因斯坦

经验是智慧之父，记忆是智慧之母。
— 谚语

任何数学技巧都不能弥补信息的缺失。
— Cornelius Lanczos，1964

智慧的艺术是知道该忽视什么。
— 威廉·詹姆斯

大脑有大约1014 个突触，我们只能活大约109 秒。
所以我们有比数据更多的参数。这启发了我们必须进行大量无监督学习的想法，因为感知输入（包括本体感受）是我们可以获得每秒105 维约束的唯一途径。
— Geoffrey Hinton, 2014 AMA on Reddit

概率论只不过是把常识归纳为计算问题。
— 皮诶尔·西蒙·拉普拉斯

计算的目的不在于数据，而在于洞察事物。
— 理查德·卫斯里·汉明

我不能创造的东西，我就不了解。
— 理查德·菲利普·费曼

除了试图直接去建立一个可以模拟成人大脑的程序之外，为什么不试图建立一个可以模拟小孩大脑的程序呢？
如果它接受适当的教育，就会获得成人的大脑。
— 阿兰· 图灵

人类语言似乎是一种独特的现象，在动物世界中没有显著类似的存在。
— 诺姆·乔姆斯基



# 其他

淹没在数据中，饿死在信息中。

技术（深度学习）-学术（神经科学）-艺术（哲学、意识的物质基础）

几乎所有程序员都梦想过，设计一门自己的语言，实现一个自己的操作系统，然后用华丽丽的视觉特效，赢得女神的惊叹。

Any sufficiently advanced technology is indistinguishable from magic.

ERP -> MVC -> 中台 -> 低代码(Low Code) -> No Code

上班Python，下班Matlab

一般工程目录
data/(ln -s target directory): 输入数据
src/
out/
.gitigore
conf.m
readme.md

# 《程序员修炼之道》
周遭所见，皆是变数和衰败。（熵增、智能熵减）

温和的超出用户的预期。

在你的作品上前签名。

类应该包含他们自己的测试代码。

正如《程序员修炼之道》中引用中世纪矿工的信条那般：“我等采石之人，当心怀建造大教堂之愿景。”

这指的就是如果你是个手工艺人，当你专注于一件事情，会逐渐懂得对自然和传统的敬畏，而且不会变得傲慢。

我们，采集的只是石头，却必须时刻展望未来的大教堂。  ——采石工人的信条

手艺人 -> 工程学科

在所有弱点中，最大的弱点就是害怕暴露弱点。

提供各种选择，不要找蹩脚的借口。

不要容忍破窗户。

做变化的催化剂。（渐进地欺骗村民，是在做石头汤还是青蛙汤）

记住大图景。

欲求更好，常把事情变糟。

使质量成为需求问题。

知道何时止步。

知识上的投资总是能得到最好的回报。

定期为你的知识资产投资。

思想的“异花授粉”十分重要。

批判并分析你读到的和听到的。

我相信，被打量比被忽略要好。

你说什么和你怎么说同样重要。

不要重复你自己。

让复用变得简单。

正交性，表示某种不相依赖性或是解耦性。

如果某个想法是你唯一的想法，再没有什么比这更危险的事情了。

不存在最终决策。

预备、开火、瞄准... 曳光弹与常规弹药交错着装在弹药袋上。

用曳光弹找到目标。

曳光代码 vs 原型制作

为了学习而制作原型。（原型制作的在于学到的经验教训）

语言的极限就是一个人的世界的界限。

靠近问题领域编程。

估算，以避免发生意外。

通过代码对进度表进行迭代。

当他听到刨子划过木料发出的歌声时，那是他最高兴的时候。

工具放大你的才干。（让需求驱动你的采购）

手指在键盘上移动，操纵文本，却不用进行有意识的思考，工具将变成你双手的延伸。

持久地存储知识的最佳格式是纯文本。（获得自描述的、不依赖于创建它的应用的数据流）

用纯文本保存知识。

GUI的好处————所见即所得（what you see is what you get）；
缺点是————所见即全部所得（what you see is all you get）

GUI受限于他们设计者想要提供的能力。

find . -name '*.c' -newer Makefile -print
利用shell命令的力量

用好一种编辑器

进步远非由变化组成，而是取决于好记性。不能记住过去的人，被判重复过去。

总是使用源代码控制(git)。

这是痛苦的事：看着你自己的烦恼，并且知道，不是别人、而是你自己一个人所致。 ————索福克勒斯《埃阿斯》

修改问题，而不是发出指责。

最容易欺骗的人是一个人自己。

调试的第一准则：Don't Panic

“Select"没有问题。 
如果看到马蹄印，要想到马，而不是斑马。
OS很可能没有问题。

不要假定，要证明。

学习一种文本操作语言。

使自己免于患上腕部劳损综合症。

编写能写代码的代码。

你不可能写出完美的软件。

通过合约进行设计。

早崩溃。（要奔溃，不要破坏）

在自责中有一种满足感。当我们责备自己时，会觉得在没人有权责备我们。

如果它不可能发生，用断言确保它不会发生。

死程序不说谎。（程序都崩溃了，还说不可能发生）

再多的天才也无法胜过对细节的专注。

要配置，不要集成。

将抽象放进代码（操作），细节放进元数据（数据的定义）。

不要编写渡渡鸟代码。  （适应性、灵活性）（渡渡鸟和鲸头鹳这样的傻鸟一样，并不惧怕人类，只要人类不怎么吓唬它，很容易就能靠近并捕捉渡渡鸟。）
在英语中，渡渡鸟一词不仅是一个名词，它已经衍生到象征“死亡、死灰”，或者“过时、过气了”这样的意思，在葡萄牙语中大概意思是“笨蛋”。

分析工作流，以改善并发性。

那人依然只听到，他想要听到的东西，而不顾其他。啦——啦——啦——

用黑板协调工作流。

不要靠巧合编程（试探一下没有地雷就认为都没有雷），要深思熟虑地编程。

周遭所见，皆是易变与衰败...

早重构，常重构。

为测试而设计。（论文也是，先有个预期的目标）

测试你的软件，否则你的用户就得测试。

不要使用你不理解的向导代码。

完美，不是在没有什么需要增加、而是在没有什么需要去掉时达到的。

不要收集需求————挖掘他们。（既收集、又挖掘，满足能满足的，然后培养用户需求）

与用户一同工作，以像用户一样思考。

抽象比细节活得更长久。（细节->抽象->思想）

使用项目词汇表（用户和开发者使用同一名称指代同一事物）

有些约束是绝对的，有些只是先入之见。（没有人能解开的结）

不要在盒子外思考————要找到盒子。

有时犹豫的人会得以保全。

不要做形式方法（基于数学推理）的奴隶。 （或者只有结构化设计拥有长久的生命）
结构化分析 是一种面向功能或面向数据流的需求分析方法，采用自顶向下、逐层分解的方法，建立系统的处理流程。

昂贵的工具不一定能制作出更好的设计。

围绕功能、而不是工作职务进行组织。

文明通过增加我们不加思索就能完成的重要操作的数目而取得进步。

不要使用手工流程。 

无情的测试。  早测试，常测试，自动测试。

记忆是随着你的年龄增加而丧失的第二种东西，我不想你不想过分依赖它。（第一种是什么？我忘了，哈哈）

鞋匠的孩子没有鞋穿。
這句英国谚语道出一個事实,鞋匠忙著为客戶做鞋子,忙到沒有时间为自己的孩子做双鞋。用这个比喻来形容资讯科技 (IT)产业,也非常貼切。

要到通过全部测试，编码才算完成。

通过”蓄意破坏“测试你的测试。

测试状态覆盖，而不是代码覆盖。

一个bug只抓一次。（对自动化测试进行修改）

把英语当作一种编程语言。

把文档建在里面，不要栓在外面。（文档和代码不分开，可以用命令或工具生成文档）

任何形式的文档都只是快照（snapshot）。

诸天啊，要因此惊奇，及其恐慌。（想到你们自己怎样任意犯罪得罪这位如此伟大荣耀的神，内心至少也应该充满同样的战栗和恐慌）

温和地超出用户的期望。

你愉悦我们已经足够长久。

在你的作品上签名。

（最后）注重实效的程序员之快速参考指南。



几乎所有程序员都梦想过，设计一门自己的语言，实现一个自己的操作系统，然后用华丽丽的视觉特效，赢得女神的惊叹。

软件2.0：数据结构+算法 -> 模型（架构搜索）+算力（深度学习）RL不需要标签数据

落指无悔

掌握过度设计和上手就开始编码之间的度

代码雨: cmatrix
cmatrix -b -u 3 -C red
跑火车：sl
hollywood

不是所有的技术我们都需要做，但不能不会做。（可控）

工程师是科学家；工程师是艺术家；工程师也是思想家。

一只船孤独的航行在海上，它既不寻求幸福，也不逃避幸福，它只是向前航行，底下是沉静碧蓝的大海，而头顶是金色的太阳。  
——俄 莱蒙托夫

所有脑力劳动，在熟练之后，都会转变成体力劳动。

做项目是提升个人能力最快的方式。

别让自动化的努力变成剪牦牛毛。
剪牦牛毛是一件很危险的事，它会吃掉你大把的时间，得到的却只是一个不实用、只能用几次或者隐患很大的脚本工具。

life is short, we need python.
Life is short, import your readme.

清心寡欲，做一个专注的程序员。

昏光台灯旧书，老牛破车电脑。

人和动物的本质区别在于人会制作、使用工具！撸代码亦是如此！

为系统而生，为框架而死，为debug奋斗一辈子； 吃符号的亏，上大小写的当，最后死在需求上。

精于码，匠于心，品于行——追求精益求精的匠人精神。

设计师灵魂里住着一个工匠，注重细节、追求完美和孜孜不倦的努力。

没有工具是永恒的，即便是反向传播或深度学习

大部分人类知识是围绕因果关系组织的，而不是概率关系（因果vs概率）

你认为你是你自己是因为你的存储器的原因。
小时候你记不清的事情不是因为你忘记了，是因为指针丢失了。
遗忘的分子机制：以形成的突触消失（指针丢失）；RNA和蛋白质降解（磁盘消磁）。

俗话说，两长一短，项目被砍，一短两长，产品要黄。
编程的尽头是数学，Debug的尽头是玄学
上联，代码千万行注释第一行，下联，命名不规范调试两行泪，中间挂雍正照片，专治八阿哥。

想靠爬树抵达月亮一样：他将不断进步，直到树的尽头。

Code is document. 代码即文档

不能铭记过去的人注定要重蹈覆辙。

如果一个问题无解，那它可能都不成问题，而是一个事实；我们不需要解决，而是随着时间推移来处理。

我们的机遇就在那些“无解问题”之中。

最黑暗的时刻，是黎明来临之前。

# 数学
莫比斯环只有一面

皮亚诺曲线可以遍历单位正方形中所有的点，是一条充满空间的曲线

克莱因瓶就没有“内部”和“外部”之分

魏尔斯特拉斯函数连续但处处不可导，也就是这货本来就没有“曲”的概念

空集既是开集也是闭集

康托尔集是个测度为0的集，用简单的解析几何说法就是这函数图像面积为0

黎曼几何没有平行线

狄利克雷函数无法画出图像

莱洛三角形勒洛三角形是定宽曲线，用它来搬运东西，不会发生上下抖动

克苏鲁神话是越深入学习越会导致人物疯狂的知识。

薛定谔之猫永远不知道它是死是活

薛定谔方程表明量子力学中，粒子以概率的方式出现，没有规律

熵只增不减的量

典型悖论：我说的话全是假话。

拉萨的水呀，90度都沸腾了！

交换代数：此理想不同于彼理想······

电脑万岁，#python#万岁，l='l=%s;printl%%`l`';print l%`l` 万岁······

费米子(fermion)：自旋为半整数的粒子。

大师终于学聪明了，安利确实好万能！

还可以加氢氟酸溶解掉沙石蒸去残液，再高温熔融，最后还原成硅单质并且做成闪存装满数据。

谢尔宾斯基地毯它本身的一部分完全相似。减掉一块会破坏自相似性

左手代码，右手年华。
左手代码，右手诗文。
左手文档，右手代码。 --matlab(python)

mathematica可能是数学界最好的狙击枪，但Matlab能给你一座军火库。
Matlab除了生孩子，什么都会。（技穷限制了想象力）

There are only two hard things in Computer Science: cache invalidation and naming things.

程序员与AI机器人一起结对编程。

在不同的牌子挑来挑去，人就会变得浮躁。

伟大的失败和伟大的胜利一样可贵。

编解码器的结构无法解释，也导致了其无法设计。

以增量的方式编程，并且测试先行。

面朝电脑背靠背

我们不生产代码，我们只是代码的搬运工。

面向对象面向君，不负代码不负卿

内事不决问百度，外事不决问谷歌

The devil is in the details

为什么有这么多入门的教程，因为大部分人都在入门。

# 开源
选择一个团队，而不是一个人单枪匹马。

如果说从无到有的时代英雄属于个人，那么到了群星璀璨的现在，英雄已经成了“一群人”：
没有团队，一个人难以应对每次高峰流量的冲击，也搞不定低层的技术建设。

好的代码是改出来的。

Committer: 技术和代码的“守门员”。

开源社区食堂一场永不终结的Hackathon，（黑客马拉松）
成为Committer就意味着变成领跑者之一，长期主义才能最终胜出！

“代码活化石”、行动派

Stay hungry. Stay foolish.

在了解的基础上，喜爱-> 而不是错爱。

马斯洛需求层次理论：
自我实现需求：我要改变世界；
尊重需求：我的工作与能力被社区认可；
社交需求：我要加入XXX技术的核心圈；
安全需求：我要确保在社区里顺利的推进工作；
生理需求：我要完成目标；

从“小乘”走向“大乘”

讨论，不要三思而后行；坦率；频繁

参与发布版，成为Release Manager。

坚持中立性、原则性。

evangelist 福音传道者

时间有限。向内探索，答案就在那里。

双手沾泥，用贡献说话，用技术实力说话。
建立自我，追求无我。

Do not reinvent the wheel.

技术三大定律：
技术惯性定律、技术变革定律，技术作用力和反作用

技术没有足够好，产生足够的改变力。

成功是成功之母。



# 极限编程 XP
以增量的方式编程，并且测试先行。

重构，改进现有代码的设计。

结对编程令人精疲力尽，但它又卓有成效。

体系结构体现在探究中，体现在隐喻中，体现在第一次迭代以及别的地方。

系统隐喻是一种描述，每个人——客户、程序员和经理都可以使用它来讲述系统是如何工作的。

编写、估算和故事的优先级排序。

可以把迭代计划想象成棋盘游戏。

客户：解答问题、测试和指导
程序员：测试、编码和重构
经理：项目经理、跟踪者和教练

对消费主义最彻底的反叛。

大部分问题都是收集数据比明确地编写程序更容易。可微分编程

社会正在惩罚善良泛滥的人。
“善良”这个词越来越贬义化。

不忘初心，方得始终，未来已来，星辰大海。

作为工匠，我更愿意把我有限的生命用在作品上，而不是对工具的无止境的学习上。
（论文也是，把自己的目标放在探索上，需要啥工具就上手一个原型并尝试解决问题）

未来属于我们当中那些仍然愿意弄脏双手的少数分子!

在信息时代，客观障碍已不复存在，所谓障碍都是主观上的。
如果你想动手开发什么全新的技术，你不需要几百万美元的资金，
你只需要在冰箱里放满比萨和可乐，再有一台便宜的计算机，和为之献身的决心。
我们在地板上睡过，我们从河水中趟过。

代码是自具文档化的self-documenting
阅读源代码就想听天气预报一样：明智的人依然出门会看看室外的天气。

待我消除bug（代码编成），娶你为妻可好。

写代码比打游戏还要爽！

直觉机器和理性机器之间的语义鸿沟将被弥合。

人类无法掌握过多的规则；
机器创造的概念是完全陌生和违反规则的。

预测未来最好的方式是创造未来
真正认真对待软件的人应该做自己的硬件。

编程技术包括：HelloWorld, Github, 不修电脑

明治时期的手艺人被天皇召见，虽然都是不读书的乡下人，但一辈子兢兢业业地做一件事情，自然有一股高贵的气质。

搜索引擎、不相信重复、代码片段、自动化

[技术上无法实现]vs[Facebook可以做到为什么我们做不到]

IT时代的膨胀，已让程序员如同文艺复兴时的印刷匠一样的普通。

机器学习已经成为炼金术师。
炼金术士有效的（对于很多事情）
但科学家已推翻两千年的炼金术理论
我想生活在一个社会，这个社会的制度建立在可证实的严谨的知识上，而不是炼金术上。
当一个深度网络不起作用时，我认为它是梯度下降的错误。

成为一个单纯的“炼金术师”并不可耻，可耻的是并不努力从“炼金术师”学成“化学家”
仅仅反复的做工程实践并没有什么不对，但是还应该想想背后的原理。
不想当将军的士兵不是好兵？

Model-View-Presenter(MVP)
Model-View-ViewModel（MVVM）

Get hands dirty. 撸起袖子加油干。

左手程序员，右手作家；Jupyter Notebook
文学编程（Literate programing）
结构化编程：按照计算机的逻辑顺序来编写代码）；
文学编程：按照自己的逻辑来开发程序。

Open source is not only a kind of behavior, it is a faith. 开源不仅仅是一种行为，它是一种信仰。

Engineering isn't about perfect solutions; it's about doing the best you can with limited resources.

要穿拖鞋，宽松裤子，手机扔一边，qq微博知乎还有各种网站不能上不能上不能上。

Linux的最初的理念就是KISS，“KeepIt Simple,Stupid!”的缩写;一切都是文件

Emacs: https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org

不是去写程序，而是设计程序；编程到深处，与写文章并无二异。

认为并不存在「通用」智能这种东西。
从抽象层次上说，这是从「没有免费午餐」定理中得出来的结果。
该理论指出，没有任何问题解决算法能够比纯随机搜索算法更优。
如果智能是一个问题解决算法，那么它只能被应用于一个具体的问题。
具体的说，我们根据经验可知所有的智能系统都是高度专业化的。
我们今天构建的 AI 智能高度专一于极端狭隘的任务，比如下围棋或将图像分成 10000 个类。章鱼的智能只能专用于章鱼的问题。人类的智能只能专用于人类的问题。

智能是情境式的。

任何技术“原理不变”，“都是人写成的”。

这不是第一次机器超过人类。挖掘机比我们用铲子挖的更好，但我们不会被挖掘机吃掉。汽车也比我们跑的更快……

即使翅膀折了，心也要飞翔。

为你遮风避雨，与你潮起潮落。

真正了不起的程序员对自己的程序的每一个字节都了如指掌。

人傻：用心（修电脑）、帅（没打扮）
钱多
死得早：据联合国统计，目前没有一位90后程序员活过30岁。

一个合格的程序员是不会写出 诸如 “摧毁地球” 这样的程序的，他们会写一个函
数叫 “摧毁行星”而把地球当一个参数传进去。

继承，是幸福的延续；重载，是幸福的重生。

如果你的朋友最近没和你联系，要理解！只有三种可能：第一，他死了；第二，他
改行当程序猿了；第三，需求又改了！

做为一名程序员，我每次看到工资单的时候，都会想：那些数字为神马不是16进制。

编程是一种单调的生活，因此程序员比普通人需要更多的关怀，更多的友情。

永不放弃，永不放弃又有两个原则，第一个原则是永不放弃，第二个原则就是：当你想放弃时回头看第一个原则。

理想如果不向现实做一点点屈服，那么理想也将归于尘土。

完美主义者常常因试图努力把一件事做好而放弃对新领域的尝试，从而使做事的机会成本增加，有时回头一看才发现，自己在某件事上，已经花了太多时间，
而实际上，暂时的妥协可能并不会影响到最终完美结果的呈现，因为不但知识需要积累，事情之间也总是有关联的。

一个人写的烂软件将会给另一个人带来一份全职工作

如果建筑工人像程序员写软件那样盖房子，那第一只飞来的啄木鸟就能毁掉人类文明。
如果程序员像建筑工人那样写代码，那一只臭虫就能毁掉人类现代文明。

这世界最有可能毁灭的方式——大多数专家都同意——是次意外。这就是为什么会有我们，我们是计算机专家，我们创造意外。

我们这个行业有个特别奇怪的现象：不仅我们不从失败里吸取教训，同时也不从成功中学习经验。

一种新技术一旦开始流行，你要么坐上压路机，要么成为铺路石。

所有的程序员都是编剧，所有的计算机都是烂演员。

为什么我们没有时间把事情做对，却总有时间把事情做过头？

在水上行走和按需求文档开发软件都很容易——前提是它们都是冻结状态。

注释代码很像清洁你的厕所——你不想干，但如果你做了，这绝对会给你和你的客人带来更愉悦的体验。

软件设计最困难的部分…是阻挡新功能的引入。

为了理解递归，我们首先要理解的是递归。

理论上，理论和实践是没有差异的。但实践中，是有的。

预备，开火，瞄准：这是最快的软件开发方法。
预备，瞄准，瞄准，瞄准，瞄准：这是最慢的软件开发方法。

编程是10%的科学，20%天份，和70%的让这天份符合科学。

评估一个事情要比去理解你评估了什么容易。

测评不会撒谎，但测评的人会。

Java之于JavaScript如同Car之于Carpet。

程序必须是为了给人看而写，给机器去执行只是附带任务。 

编程可以很有趣，你可以用它做密码学研究，但两者绝对不能合二为一。

删除的代码是没有bug的代码。

代码纠错要比新编写代码困难一倍。因为，如果你写出了最聪明的代码，按此推算，你将没有更大的智慧来debug它。

这不是个bug——这一个未注明的功能特征。

没有需求或设计，编程就是一种将bug添加到一个空文本文件里的艺术。

软件通常在beta测试完成不久后发布。Beta在拉丁语中是“还不能用”的意思。

最廉价、最快速、最可信赖的组件是那些还未出现的组件。

软件和教堂非常相似——建成之后我们就在祈祷。

除非最后一个用户死掉，软件是不会有完工的时候的。

如今的大部分软件都非常像埃及金字塔，由成千上万的石块一个摞一个构成，没有结构上的集成，是由暴力强制和成千上万的奴隶完成

正确的时候，读合适的书！



http://yuedu.mipang.com/lizhi/mingyan/chengxuyuan/
http://news.mydrivers.com/1/286/286894.htm
http://blog.csdn.net/mexican_ok/article/details/14227559



We believe that writing is about content, about what you want to say – not about fancy formatting. 
我们坚信写作写的是内容，所思所想，而不是花样格式。
— Ulysses for Mac

空格不要钱

祝大家事业顺利，万码奔腾，做啥啥work！

以目标为导向

根据我的经验，使用基本命令式编程结构的能力并不像人们想象的那样广泛。
在一个团队中，有时我能发现一些非常不称职的程序员，他们甚至都弄不懂一个简单的排序算法，
但能比那些刚毕业的理论上很强但实际动手能力很弱的程序员完成更多的工作。

尝试提高注意力并减少中断将对编程生产力产生非边际效应。
为了集中注意力，有时需要采取一些极端措施。
例如，我只是偶尔查看一下电子邮件，并且大部分的邮件都不回复。

对于一个设计师来讲，要识别一个设计中所有不重要的部分是非常重要的，也就是说，努力与优势之间并不是线性关系。
为了让项目得到最大化的输出，需要把注意力集中到那些重要的、并且可以在合理的时间内实现的目标上。

完美主义有两种形式：在程序中要达到最佳可衡量的性能的工程师文化，以及个人的性格特征。我认为这是程序员快速交付项目的最大障碍之一。

“机会主义编程”，那就是在每个开发步骤中，选择最重要的能对用户产生最大影响，但是工作量又是最小的的功能集。



